

using NCDatasets
using NearestNeighbors

"""
    gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    Output the standard map filename with input folder name
"""
function gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    filename = fldr*"/scrip-"*method*"_"*src_name*"_"*dst_name*".nc"

    return filename

end

"""
    countoccurances(itr)

    Count occurrences of different values in an array.
"""
function countoccurances(itr;wts::Union{T,Nothing}=nothing) where T
    d = Dict{eltype(itr), Float64}()
    if isnothing(wts)
        wts = fill(1.0,length(itr))
    end
    for (val,wt) in zip(itr,wts)
        if isa(val, Number) && isnan(val)
            continue
        end
        d[val] = get(d, val, 0.0) + wt
    end
    return d
end

"""
    map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    Load a map_scrip_class object into memory
    from a netcdf file. 
"""
function map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    # Determine filename from grid names and folder 
    filename = gen_map_filename(src_name,dst_name,fldr,method)

    println("Loading SCRIP map from file: "*filename) 
    
    # Initialize dictionary to store map 
    map = Dict();

    # Store initial info about current map
    map["src_name"]  = src_name 
    map["dst_name"]  = dst_name 
    map["map_fname"] = filename

    
    # Open map file (NetCDF)
    nc = NCDataset(filename)

    # Get dimension sizes
    map["src_grid_size"] = nc.dim["src_grid_size"]
    map["dst_grid_size"] = nc.dim["src_grid_size"]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corners"] = nc.dim["dst_grid_corners"]
    else
        map["dst_grid_corners"] = 0
    end

    map["src_grid_rank"] = nc.dim["src_grid_rank"]
    map["dst_grid_rank"] = nc.dim["dst_grid_rank"]
    map["num_wgts"]  = nc.dim["num_wgts"]
    map["num_links"] = nc.dim["num_links"]

    # Load map from file 
    # Note: it seems dst_grid_corner_lat and dst_grid_corner_lon
    # do not exist in all map files generated by cdo. This may be 
    # related to the type of grid, but it is unclear. Nonetheless,
    # these variables are so far not used in the map_field routine above.
    # Below they are only read-in if available. 
    map["src_grid_dims"]        = nc["src_grid_dims"][:]
    map["dst_grid_dims"]        = nc["dst_grid_dims"][:]
    map["src_grid_center_lat"]  = nc["src_grid_center_lat"][:]
    map["dst_grid_center_lat"]  = nc["dst_grid_center_lat"][:]
    map["src_grid_center_lon"]  = nc["src_grid_center_lon"][:]
    map["dst_grid_center_lon"]  = nc["dst_grid_center_lon"][:]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corner_lat"] = nc["dst_grid_corner_lat"][:]
    end 
    if "dst_grid_corner_lon" in keys(nc)
        map["dst_grid_corner_lon"] = nc["dst_grid_corner_lon"][:]
    end
    map["src_grid_imask"] = nc["src_grid_imask"][:]
    map["dst_grid_imask"] = nc["dst_grid_imask"][:]
    if "src_grid_area" in keys(nc)
        map["src_grid_area"] = nc["src_grid_area"][:]
    end
    if "dst_grid_area" in keys(nc)
        map["dst_grid_area"] = nc["dst_grid_area"][:]
    end
    map["src_grid_frac"] = nc["src_grid_frac"][:]
    map["dst_grid_frac"] = nc["dst_grid_frac"][:]
    map["src_address"]   = nc["src_address"][:]
    map["dst_address"]   = nc["dst_address"][:]
    map["remap_matrix"]  = nc["remap_matrix"][:]
    
    close(nc)

    # Summary print line
    println("Loaded "*method*" SCRIP map: "*map["src_name"]*" => "*map["dst_name"])
    
    return map

end

"""
    map_scrip_field(map::Dict,var_name::String,var1::Array{T,2},method::String,reset::logical,
                            missing_value::T,mask_pack::Array{logical,2},fill_method::String,
                            filt_method::String,filt_par::Array{Real},verbose::logical)

    Map a variable field var1 from a src_grid to variable field var2 on dst_grid 

    Note: method='mean' is analogous to the method normalize_opt='fracarea' 
    desribed in the SCRIP documention (Fig. 2.4 in scripusers.pdf). The 
    other methods normalize_opt=['destarea','none'] have not been implemented.
"""
function map_scrip_field(map::Dict,var_name::String,var1::Array{T,2};method::String="mean",
                            mask_pack::Union{Array{Bool,2},Nothing}=nothing,verbose::Bool=false) where T

# fill_method::String,filt_method::String,filt_par::Array{Real}

    # Local variables 
    # integer :: n, k, npts1, npts2
    # character(len=56) :: method_interp         
    # logical           :: reset_pts
    # double precision  :: missing_val 
    # logical           :: verbose_out
    # logical, allocatable  :: maskp(:)
    # real(dp), allocatable :: area(:)
    # integer :: i, j, j1, j2  

    # real(dp), allocatable :: var1_vec(:)
    # real(dp), allocatable :: var2_vec(:) 
    # integer, allocatable  :: mask2_vec(:) 
    # real(dp) :: area_tot, pt_ave, pt_var   
    # integer  :: npt_now, num_links_now 
    # integer, parameter :: max_num_links_now = 10000
    # real(dp), dimension(max_num_links_now) :: var1_now 
    # real(dp), dimension(max_num_links_now) :: wts1_now 
    # real(dp) :: wts1_tot 

    # logical, allocatable  :: maskp2d(:,:) 

    # integer :: npts_apply 
    # real(dp) :: mean2, mean2b           ! Check mean before/after filtering

    # Confirm that source (var1) array matches map. 
    @assert length(var1) == map["src_grid_size"] 

    npts1 = length(var1);
    npts2 = map["dst_grid_dims"][1]*map["dst_grid_dims"][2];

    # By default, all var2 points are interpolated
    
    if isnothing(mask_pack)
        maskp_vec = fill(true,npts2);
    else
        maskp_vec = reshape(mask_pack,npts2);
    end

    # Count total points to be applied 
    npts_apply = sum(maskp_vec);
    
    # Store var1 in vector format 
    var1_vec = reshape(var1,npts1);
    
    # Initialize the output vector of interpolated points
    # and a mask to keep track of which points were interpolated.
    var2_vec = fill(NaN,npts2);
    mask2_vec = fill(false,npts2);

    j1 = 0; 
    j2 = 0;

    # Loop over target points
    for k = 1:npts2 

        # Find the range of link indices that correspond 
        # to the current point k, ie, such that:
        # map%dst_address(j1:j2) == k 
        # Note: dst_address can be expected to be sorted 
        # in ascending order.
        j1 = j2+1;

        if j1 > length(map["dst_address"])
            break 
        end

        # Check index associated with this address. If 
        # it is greater than the current index k, it 
        # means this point has no interpolation links,
        # so skip this iteration of the main loop.
        if map["dst_address"][j1] > k 
            j1 = j1-1 
            continue 
        end

        # Given j1 is the start of the addresses associated 
        # with the current index k, find the upper range 
        # such that map["dst_address"][j1:j2] == k and it 
        # covers all addresses equal to k.
        for j = j1:map["num_links"]
            if map["dst_address"][j] == map["dst_address"][j1] 
                j2 = j 
            else 
                break 
            end 
        end 

        # Determine the current number of links 
        num_links_now = j2-j1+1;

        if maskp_vec[k]
            # Only interpolate for desired target points 

            # Assign data and weights to current vectors
            var1_now = var1_vec[map["src_address"][j1:j2]]
            wts1_now = map["remap_matrix"][1,j1:j2]

            # Calculate the total weight associated with this point,
            # accounting for missing values in the source array.
            kk = findall(.! isnan.(var1_now));
            wts1_tot = sum(wts1_now[kk]);

            if wts1_tot > 0.0 
                # Interpolation data found, proceed to interpolate this point

                var2_vec[k]  = 0.0
                mask2_vec[k] = true

                if method == "mean"
                    # Calculate the area-weighted mean 

                    var2_vec[k] = sum((wts1_now[kk] ./ wts1_tot) .* var1_now[kk])
                
                elseif method == "count"
                    # Choose the most frequently occurring value, weighted by area

                    tmp = countoccurances(var1_now[kk];wts=wts1_now[kk]);
                    var2_vec[k] = findmax(tmp)[2]; 
                
                elseif method == "stdev"
                    # Calculate the weighted standard deviation 
                    # using unbiased estimator correction 

                    npt_now = length(kk);

                    if npt_now > 2
                        # Only calculate stdev for 2 or more input points

                        pt_ave      = sum((wts1_now[kk] ./ wts1_tot) .* var1_now[kk])
                        var2_vec[k] = (npt_now/(npt_now - 1.0)) *
                                        sum((wts1_now[kk] ./ wts1_tot) .* (var1_now[kk] .- pt_ave).^2)
                        var2_vec[k] = sqrt(var2_vec[k]);

                    else
                        # Otherwise assume standard deviation is zero 
                        var2_vec[k] = 0.0 

                    end

                else

                    error("map_scrip_field:: Interpolation method not recognized. method = $method_interp")
                
                end 

            end

        end 

    end # End loop over target points, interpolation complete.

    # Send back to 2D arrays
    var2  = reshape(var2_vec,Tuple(map["dst_grid_dims"]))
    mask2 = reshape(mask2_vec,Tuple(map["dst_grid_dims"]))

    # # Allocate mask if needed 
    # if (present(fill_method) .or. present(filt_method)) then

    # allocate(maskp2d(size(var2,1),size(var2,2)))
    # maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])

    # end if 

    # === Filling ===
    # Fill in remaining missing values 

    # if (present(fill_method)) then 

    #     select case(trim(fill_method))

    #     case("weighted")

    #     call fill_weighted(var2,missing_val,n=6,mask=maskp2d)

    #     case("nn")

    #     call fill_nearest(var2,missing_val,mask=maskp2d)

    #     case("none") # eg "none"

    #     # Pass - no filling applied 

    #     case DEFAULT 

    #     write(*,*) "map_scrip_field:: Error: fill method not recognized: "//trim(fill_method)
    #     write(*,*) "  fill_method = [weighted,nn,none]."
    #     write(*,*) 
    #     stop 

    #     end select

    # end if 

    # === Filtering ===
    # Now perform filtering (smoothing) steps if
    # the right arguments have been provided. 

    # if (present(filt_method)) then 

    #     # Update maskp2d to also reflect missing values 
    #     maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])
    #     maskp2d = (maskp2d .and. var2 .ne. missing_val)

    #     # Calculate grid average before filtering 
    #     if (verbose_out .and. npts_apply .gt. 0) then 
    #     mean2 = sum(var2,mask=maskp2d) / real(npts_apply,dp)
    #     end if 

    #     select case(trim(filt_method))

    #     case("gaussian")

    #     call filter_gaussian(var2,sigma=filt_par(1),dx=filt_par(2),mask=maskp2d)

    #     case("gaussian-fast")

    #     call filter_gaussian_fast(var2,sigma=filt_par(1),dx=filt_par(2),mask=maskp2d)


    #     case("poisson")

    #     call filter_poisson(var2,mask=maskp2d,tol=filt_par(1), &
    #     missing_value=missing_val,wrapx=.FALSE.,verbose=.FALSE.)

    #     case("none")

    #     # Pass - no filtering applied 

    #     case DEFAULT

    #     write(*,*) "map_scrip_field:: Error: filtering method not recognized: "//trim(filt_method)
    #     write(*,*) "  filt_method = [gaussian,gaussian-fast,poisson,none]."
    #     write(*,*) 
    #     stop 

    #     end select 

    #     # Calculate grid average after filtering 
    #     if (verbose_out .and. npts_apply .gt. 0) then 
    #     mean2b = sum(var2,mask=maskp2d) / real(npts_apply,dp)
    #     end if 

    #     if (verbose_out) then 
    #     # Print summary of filtering 
    #     write(*,"(4a,2g14.5)") var_name, " - ",filt_method, ": mean[orig,filtered]: ", mean2, mean2b
    #     end if 

    # end if 

    return mask2, var2

end

function fill_nearest!(var;xx=nothing,yy=nothing)

    # Determine which points need to be filled in
    kk = findall(isnan.(var));
    
    if length(kk) > 0
        # NaNs are present, make sure the 2D 
        # x and y locations are defined.

        if isnothing(xx) || isnothing(yy)
            # Get indices of matrix
            inds = CartesianIndices(var);

            if isnothing(xx)
                xx = Float64.(getindex.(inds,1)); 
            end
            
            if isnothing(yy)
                yy = Float64.(getindex.(inds,2));
            end
        
        end

        # Populate a matrix of x and y locations
        locs = fill(NaN,2,length(var));
        locs[1,:] = reshape(xx,length(var));
        locs[2,:] = reshape(yy,length(var));

        # Generate KD-tree of locations
        kdtree = KDTree(locs);

        while length(kk) > 0
            # Iterate until all NaNs are filled in

            # Loop over missing values and fill in with closest neighbor
            for k in kk
                xy_now = [xx[k],yy[k]];
                ii, dists = knn(kdtree, xy_now, 100, true);

                kk1 = findall(.!isnan.(var[ii]));
                if length(kk1) > 0
                    var[k] = var[ii[kk1[1]]]
                end

            end

            # Update NaN count 
            kk = findall(isnan.(var));
            
        end

    end

    return
end