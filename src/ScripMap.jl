

using NCDatasets


"""
    gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    Output the standard map filename with input folder name
"""
function gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    filename = fldr*"/scrip-"*method*"_"*src_name*"_"*dst_name*".nc"

    return filename

end

"""
    map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    Load a map_scrip_class object into memory
    from a netcdf file. 
"""
function map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    # Determine filename from grid names and folder 
    filename = gen_map_filename(src_name,dst_name,fldr,method)

    println("Loading SCRIP map from file: "*filename) 
    
    # Initialize dictionary to store map 
    map = Dict();

    # Store initial info about current map
    map["src_name"]  = src_name 
    map["dst_name"]  = dst_name 
    map["map_fname"] = filename

    
    # Open map file (NetCDF)
    nc = NCDataset(filename)

    # Get dimension sizes
    map["src_grid_size"] = nc.dim["src_grid_size"]
    map["dst_grid_size"] = nc.dim["src_grid_size"]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corners"] = nc.dim["dst_grid_corners"]
    else
        map["dst_grid_corners"] = 0
    end

    map["src_grid_rank"] = nc.dim["src_grid_rank"]
    map["dst_grid_rank"] = nc.dim["dst_grid_rank"]
    map["num_wgts"]  = nc.dim["num_wgts"]
    map["num_links"] = nc.dim["num_links"]

    # Load map from file 
    # Note: it seems dst_grid_corner_lat and dst_grid_corner_lon
    # do not exist in all map files generated by cdo. This may be 
    # related to the type of grid, but it is unclear. Nonetheless,
    # these variables are so far not used in the map_field routine above.
    # Below they are only read-in if available. 
    map["src_grid_dims"]        = nc["src_grid_dims"][:]
    map["dst_grid_dims"]        = nc["dst_grid_dims"][:]
    map["src_grid_center_lat"]  = nc["src_grid_center_lat"][:]
    map["dst_grid_center_lat"]  = nc["dst_grid_center_lat"][:]
    map["src_grid_center_lon"]  = nc["src_grid_center_lon"][:]
    map["dst_grid_center_lon"]  = nc["dst_grid_center_lon"][:]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corner_lat"] = nc["dst_grid_corner_lat"][:]
    end 
    if "dst_grid_corner_lon" in keys(nc)
        map["dst_grid_corner_lon"] = nc["dst_grid_corner_lon"][:]
    end
    map["src_grid_imask"] = nc["src_grid_imask"][:]
    map["dst_grid_imask"] = nc["dst_grid_imask"][:]
    if "src_grid_area" in keys(nc)
        map["src_grid_area"] = nc["src_grid_area"][:]
    end
    if "dst_grid_area" in keys(nc)
        map["dst_grid_area"] = nc["dst_grid_area"][:]
    end
    map["src_grid_frac"] = nc["src_grid_frac"][:]
    map["dst_grid_frac"] = nc["dst_grid_frac"][:]
    map["src_address"]   = nc["src_address"][:]
    map["dst_address"]   = nc["dst_address"][:]
    map["remap_matrix"]  = nc["remap_matrix"][:]
    
    close(nc)

    # Summary print line
    println("Loaded "*method*" SCRIP map: "*map["src_name"]*" => "*map["dst_name"])
    
    return map

end

"""
    map_scrip_field(map::Dict,var_name::String,var1::Array{T,2},method::String,reset::logical,
                            missing_value::T,mask_pack::Array{logical,2},fill_method::String,
                            filt_method::String,filt_par::Array{Real},verbose::logical)

    Map a variable field var1 from a src_grid to variable field var2 on dst_grid 

    Note: method='mean' is analogous to the method normalize_opt='fracarea' 
    desribed in the SCRIP documention (Fig. 2.4 in scripusers.pdf). The 
    other methods normalize_opt=['destarea','none'] have not been implemented.
"""
function map_scrip_field(map::Dict,var_name::String,var1::Array{T,2},method::String,reset::logical,
                            missing_value::T,mask_pack::Array{logical,2},fill_method::String,
                            filt_method::String,filt_par::Array{Real},verbose::logical)


    # Local variables 
    # integer :: n, k, npts1, npts2
    # character(len=56) :: method_interp         
    # logical           :: reset_pts
    # double precision  :: missing_val 
    # logical           :: verbose_out
    # logical, allocatable  :: maskp(:)
    # real(dp), allocatable :: area(:)
    # integer :: i, j, j1, j2  

    # real(dp), allocatable :: var1_vec(:)
    # real(dp), allocatable :: var2_vec(:) 
    # integer, allocatable  :: mask2_vec(:) 
    # real(dp) :: area_tot, pt_ave, pt_var   
    # integer  :: npt_now, num_links_now 
    # integer, parameter :: max_num_links_now = 10000
    # real(dp), dimension(max_num_links_now) :: var1_now 
    # real(dp), dimension(max_num_links_now) :: wts1_now 
    # real(dp) :: wts1_tot 

    # logical, allocatable  :: maskp2d(:,:) 

    # integer :: npts_apply 
    # real(dp) :: mean2, mean2b           ! Check mean before/after filtering

    npts1 = size(var1,1)*size(var1,2)
    npts2 = size(var2,1)*size(var2,2)

    ! Confirm that source (var1) and destination (var2)
    ! arrays match map. 
    if (npts1 .ne. map%src_grid_size) then 
    write(*,*) "map_scrip_field:: Error: source array and map size do not match."
    write(*,*) "size(var1): ", size(var1,1), size(var1,2), " = ", npts1
    write(*,*) "map%src_grid_size = ", map%src_grid_size 
    stop 
    end if 
    if (npts2 .ne. map%dst_grid_size) then 
    write(*,*) "map_scrip_field:: Error: dest. array and map size do not match."
    write(*,*) "size(var2): ", size(var2,1), size(var2,2), " = ", npts2
    write(*,*) "map%dst_grid_size = ", map%dst_grid_size 
    stop 
    end if 

    ! By default, method is 'mean' (conservative)
    method_interp = "mean"
    if (present(method)) method_interp = trim(method) 

    ! By default, reset target grid points to missing values initially
    reset_pts = .TRUE. 
    if (present(reset)) reset_pts = reset 

    ! By defualt missing value is the coordinates package default value
    missing_val = mv 
    if (present(missing_value)) missing_val = missing_value

    ! By default, not verbose output 
    verbose_out = .FALSE. 
    if (present(verbose)) verbose_out = verbose 

    ! By default, all var2 points are interpolated
    allocate(maskp(npts2))
    maskp = .TRUE. 
    if (present(mask_pack)) maskp = reshape(mask_pack,[npts2])

    ! Count total points to be applied 
    npts_apply = count(maskp)

    ! Store var1 in vector format
    allocate(var1_vec(npts1)) 
    var1_vec = reshape(var1,[npts1])

    ! Store var2 in vector format
    allocate(var2_vec(npts2))
    var2_vec = reshape(var2,[npts2])

    ! Allocate mask to keep track of which points have been interpolated 
    allocate(mask2_vec(npts2))
    mask2_vec = 0 

    ! Reset output points to missing values
    if (reset_pts) var2_vec = missing_val 


    j1 = 0 
    j2 = 0 

    ! Loop over target points
    do k = 1, npts2 

    ! Find the range of link indices that correspond 
    ! to the current point k, ie, such that:
    ! map%dst_address(j1:j2) == k 
    ! Note: dst_address can be expected to be sorted 
    ! in ascending order.
    j1 = j2+1 

    ! Check index associated with this address. If 
    ! it is greater than the current index k, it 
    ! means this point has no interpolation links,
    ! so skip this iteration of the main loop.
    if (map%dst_address(j1) .gt. k) then 
    j1 = j1-1 
    cycle 
    end if 

    ! Given j1 is the start of the addresses associated 
    ! with the current index k, find the upper range 
    ! such that map%dst_address(j1:j2) == k and it 
    ! covers all addresses equal to k.
    do j = j1, map%num_links
    if (map%dst_address(j) .eq. map%dst_address(j1) ) then 
    j2 = j 
    else 
    exit 
    end if 
    end do 

    ! Determine the number of links 
    num_links_now = j2-j1+1

    if (num_links_now>max_num_links_now) then
    write(*,*) "map_scrip_field:: Error: num_links_now>max_num_links_now: ", &
            num_links_now, max_num_links_now
    write(*,*) " To avoid this error, increase hard-coded variable 'max_num_links_now' &
    &in coordinates_mapping_scrip.f90."
    write(*,*) 
    stop 
    endif

    if (maskp(k)) then 
    ! Only interpolate for desired target points 

    ! Assign data and weights to pointers
    var1_now(1:num_links_now) = var1_vec(map%src_address(j1:j2))
    wts1_now(1:num_links_now) = map%remap_matrix(1,j1:j2)

    ! Calculate the total weight associated with this point,
    ! accounting for missing values in the source array.
    wts1_tot = sum(wts1_now(1:num_links_now),mask=var1_now(1:num_links_now) .ne. missing_val)

    if (wts1_tot .gt. 0.0d0) then 
    ! Interpolation data found, proceed to interpolate this point

    var2_vec(k)  = 0.0d0 
    mask2_vec(k) = 1 

    select case(trim(method_interp))

    case("mean")
    ! Calculate the area-weighted mean 

    var2_vec(k) = sum((wts1_now(1:num_links_now)/wts1_tot)*var1_now(1:num_links_now), &
                    mask=var1_now(1:num_links_now) .ne. missing_val)

    case("count")
    ! Choose the most frequently occurring value, weighted by area

    var2_vec(k) = maxcount(var1_now(1:num_links_now),wts1_now(1:num_links_now),missing_val)

    case("stdev")
    ! Calculate the weighted standard deviation 
    ! using unbiased estimator correction 

    npt_now = count(var1_now(1:num_links_now) .ne. missing_val)

    if (npt_now .gt. 2) then
    ! Only calculate stdev for 2 or more input points

    pt_ave      = sum((wts1_now(1:num_links_now)/wts1_tot)*var1_now(1:num_links_now), &
                    mask=var1_now(1:num_links_now) .ne. missing_val)
    var2_vec(k) = (npt_now/(npt_now - 1.0)) &
    * sum((wts1_now(1:num_links_now)/wts1_tot)*(var1_now(1:num_links_now)-pt_ave)**2, & 
                            mask=var1_now(1:num_links_now) .ne. missing_val)
    var2_vec(k) = sqrt(var2_vec(k))

    else
    ! Otherwise assume standard deviation is zero 
    var2_vec(k) = 0.0d0 

    end if 

    case DEFAULT 

    write(*,*) "map_scrip_field:: Error: interpolation method not recognized."
    write(*,*) "method = ", trim(method_interp) 
    stop 

    end select 

    end if 

    end if 

    end do 

    ! Send back to 2D array 
    var2 = reshape(var2_vec,[size(var2,1),size(var2,2)])

    ! Get interpolation mask too if desired 
    if (present(mask2)) then 
    mask2 = reshape(mask2_vec,[size(var2,1),size(var2,2)])
    end if 

    ! Allocate mask if needed 
    if (present(fill_method) .or. present(filt_method)) then

    allocate(maskp2d(size(var2,1),size(var2,2)))
    maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])

    end if 

    ! === Filling ===
    ! Fill in remaining missing values 

    if (present(fill_method)) then 

    select case(trim(fill_method))

    case("weighted")

    call fill_weighted(var2,missing_val,n=6,mask=maskp2d)

    case("nn")

    call fill_nearest(var2,missing_val,mask=maskp2d)

    case("none") ! eg "none"

    ! Pass - no filling applied 

    case DEFAULT 

    write(*,*) "map_scrip_field:: Error: fill method not recognized: "//trim(fill_method)
    write(*,*) "  fill_method = [weighted,nn,none]."
    write(*,*) 
    stop 

    end select

    end if 

    ! === Filtering ===
    ! Now perform filtering (smoothing) steps if
    ! the right arguments have been provided. 

    if (present(filt_method)) then 

    ! Update maskp2d to also reflect missing values 
    maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])
    maskp2d = (maskp2d .and. var2 .ne. missing_val)

    ! Calculate grid average before filtering 
    if (verbose_out .and. npts_apply .gt. 0) then 
    mean2 = sum(var2,mask=maskp2d) / real(npts_apply,dp)
    end if 

    select case(trim(filt_method))

    case("gaussian")

    call filter_gaussian(var2,sigma=filt_par(1),dx=filt_par(2),mask=maskp2d)

    case("gaussian-fast")

    call filter_gaussian_fast(var2,sigma=filt_par(1),dx=filt_par(2),mask=maskp2d)


    case("poisson")

    call filter_poisson(var2,mask=maskp2d,tol=filt_par(1), &
    missing_value=missing_val,wrapx=.FALSE.,verbose=.FALSE.)

    case("none")

    ! Pass - no filtering applied 

    case DEFAULT

    write(*,*) "map_scrip_field:: Error: filtering method not recognized: "//trim(filt_method)
    write(*,*) "  filt_method = [gaussian,gaussian-fast,poisson,none]."
    write(*,*) 
    stop 

    end select 

    ! Calculate grid average after filtering 
    if (verbose_out .and. npts_apply .gt. 0) then 
    mean2b = sum(var2,mask=maskp2d) / real(npts_apply,dp)
    end if 

    if (verbose_out) then 
    ! Print summary of filtering 
    write(*,"(4a,2g14.5)") var_name, " - ",filt_method, ": mean[orig,filtered]: ", mean2, mean2b
    end if 

    end if 


    return 

end