

using NCDatasets
using NearestNeighbors
using ImageFiltering

"""
    gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    Output the standard map filename with input folder name
"""
function gen_map_filename(src_name::String,dst_name::String,fldr::String,method::String)
    
    filename = fldr*"/scrip-"*method*"_"*src_name*"_"*dst_name*".nc"

    return filename

end

"""
    countoccurances(itr)

    Count occurrences of different values in an array.
"""
function countoccurances(itr;wts::Union{T,Nothing}=nothing) where T
    d = Dict{eltype(itr), Float64}()
    if isnothing(wts)
        wts = fill(1.0,length(itr))
    end
    for (val,wt) in zip(itr,wts)
        if isa(val, Number) && isnan(val)
            continue
        end
        d[val] = get(d, val, 0.0) + wt
    end
    return d
end

"""
    map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    Load a map_scrip_class object into memory
    from a netcdf file. 
"""
function map_scrip_load(src_name::String,dst_name::String,fldr::String;method::String="con")

    # Determine filename from grid names and folder 
    filename = gen_map_filename(src_name,dst_name,fldr,method)

    println("Loading SCRIP map from file: "*filename) 
    
    # Initialize dictionary to store map 
    map = Dict();

    # Store initial info about current map
    map["src_name"]  = src_name 
    map["dst_name"]  = dst_name 
    map["map_fname"] = filename

    
    # Open map file (NetCDF)
    nc = NCDataset(filename)

    # Get dimension sizes
    map["src_grid_size"] = nc.dim["src_grid_size"]
    map["dst_grid_size"] = nc.dim["src_grid_size"]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corners"] = nc.dim["dst_grid_corners"]
    else
        map["dst_grid_corners"] = 0
    end

    map["src_grid_rank"] = nc.dim["src_grid_rank"]
    map["dst_grid_rank"] = nc.dim["dst_grid_rank"]
    map["num_wgts"]  = nc.dim["num_wgts"]
    map["num_links"] = nc.dim["num_links"]

    # Load map from file 
    # Note: it seems dst_grid_corner_lat and dst_grid_corner_lon
    # do not exist in all map files generated by cdo. This may be 
    # related to the type of grid, but it is unclear. Nonetheless,
    # these variables are so far not used in the map_field routine above.
    # Below they are only read-in if available. 
    map["src_grid_dims"]        = nc["src_grid_dims"][:]
    map["dst_grid_dims"]        = nc["dst_grid_dims"][:]
    map["src_grid_center_lat"]  = nc["src_grid_center_lat"][:]
    map["dst_grid_center_lat"]  = nc["dst_grid_center_lat"][:]
    map["src_grid_center_lon"]  = nc["src_grid_center_lon"][:]
    map["dst_grid_center_lon"]  = nc["dst_grid_center_lon"][:]
    if "dst_grid_corner_lat" in keys(nc)
        map["dst_grid_corner_lat"] = nc["dst_grid_corner_lat"][:]
    end 
    if "dst_grid_corner_lon" in keys(nc)
        map["dst_grid_corner_lon"] = nc["dst_grid_corner_lon"][:]
    end
    map["src_grid_imask"] = nc["src_grid_imask"][:]
    map["dst_grid_imask"] = nc["dst_grid_imask"][:]
    if "src_grid_area" in keys(nc)
        map["src_grid_area"] = nc["src_grid_area"][:]
    end
    if "dst_grid_area" in keys(nc)
        map["dst_grid_area"] = nc["dst_grid_area"][:]
    end
    map["src_grid_frac"] = nc["src_grid_frac"][:]
    map["dst_grid_frac"] = nc["dst_grid_frac"][:]
    map["src_address"]   = nc["src_address"][:]
    map["dst_address"]   = nc["dst_address"][:]
    map["remap_matrix"]  = nc["remap_matrix"][:]
    
    close(nc)

    # Summary print line
    println("Loaded "*method*" SCRIP map: "*map["src_name"]*" => "*map["dst_name"])
    
    return map

end

"""
    map_scrip_field(map::Dict,var_name::String,var1::Array{T,2};method::String="mean",
                            mask_pack::Union{Array{Bool,2},Nothing}=nothing,verbose::Bool=false,
                            fill_method::Union{String,Nothing}=nothing,
                            filt_method::Union{String,Nothing}=nothing,
                            filt_par::Union{Vector{Real,2},Nothing}=nothing) where T
                            missing_value::T,mask_pack::Array{logical,2},fill_method::String,
                            filt_method::String,filt_par::Array{Real},verbose::logical)

    Map a variable field var1 from a src_grid to variable field var2 on dst_grid 

    Note: method='mean' is analogous to the method normalize_opt='fracarea' 
    desribed in the SCRIP documention (Fig. 2.4 in scripusers.pdf). The 
    other methods normalize_opt=['destarea','none'] have not been implemented.
"""
function map_scrip_field(map::Dict,var_name::String,var1::Array{T,2};method::String="mean",
                            mask_pack::Union{Array{Bool,2},Nothing}=nothing,verbose::Bool=false,
                            fill_method::Union{String,Nothing}=nothing,
                            filt_method::Union{String,Nothing}=nothing,
                            filt_par::Union{Vector{T},Nothing}=nothing) where T

    # Confirm that source (var1) array matches map. 
    @assert length(var1) == map["src_grid_size"] 

    npts1 = length(var1);
    npts2 = map["dst_grid_dims"][1]*map["dst_grid_dims"][2];

    # By default, all var2 points are interpolated
    
    if isnothing(mask_pack)
        maskp_vec = fill(true,npts2);
    else
        maskp_vec = reshape(mask_pack,npts2);
    end

    # Count total points to be applied 
    npts_apply = sum(maskp_vec);
    
    # Store var1 in vector format 
    var1_vec = reshape(var1,npts1);
    
    # Initialize the output vector of interpolated points
    # and a mask to keep track of which points were interpolated.
    var2_vec = fill(NaN,npts2);
    mask2_vec = fill(false,npts2);

    j1 = 0; 
    j2 = 0;

    # Loop over target points
    for k = 1:npts2 

        # Find the range of link indices that correspond 
        # to the current point k, ie, such that:
        # map%dst_address(j1:j2) == k 
        # Note: dst_address can be expected to be sorted 
        # in ascending order.
        j1 = j2+1;

        if j1 > length(map["dst_address"])
            break 
        end

        # Check index associated with this address. If 
        # it is greater than the current index k, it 
        # means this point has no interpolation links,
        # so skip this iteration of the main loop.
        if map["dst_address"][j1] > k 
            j1 = j1-1 
            continue 
        end

        # Given j1 is the start of the addresses associated 
        # with the current index k, find the upper range 
        # such that map["dst_address"][j1:j2] == k and it 
        # covers all addresses equal to k.
        for j = j1:map["num_links"]
            if map["dst_address"][j] == map["dst_address"][j1] 
                j2 = j 
            else 
                break 
            end 
        end 

        # Determine the current number of links 
        num_links_now = j2-j1+1;

        if maskp_vec[k]
            # Only interpolate for desired target points 

            # Assign data and weights to current vectors
            var1_now = var1_vec[map["src_address"][j1:j2]];
            wts1_now = map["remap_matrix"][1,j1:j2];

            # Determine interpolated value for this point 
            var2_vec[k]  = vec_stat(var1_now;wts=wts1_now,method=method);
            mask2_vec[k] = true;

        end 

    end # End loop over target points, interpolation complete.

    # Send back to 2D arrays
    var2  = reshape(var2_vec,Tuple(map["dst_grid_dims"]))
    mask2 = reshape(mask2_vec,Tuple(map["dst_grid_dims"]))

    # ajr: TO DO: reimplement masking for fill and filter methods 
    # (to avoid modifying points that should not be modified)

    # # Allocate mask if needed 
    # if (present(fill_method) .or. present(filt_method)) then

    # allocate(maskp2d(size(var2,1),size(var2,2)))
    # maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])

    # end if 

    # === Filling ===
    # Fill in remaining missing values 

    if isnothing(fill_method)

        # Pass, no filling needed 

    else
        # Perform filling of NaNs based on method of choice

        if fill_method == "weighted"

            fill_weighted!(var2;nmax=10)

        elseif fill_method == "nn"

            fill_nearest!(var2)

        elseif fill_method == "none" # eg "none"

            # Pass - no filling applied 

        else

            error("map_scrip_field:: Error: fill method not recognized: "*fill_method)

        end

    end

    # === Filtering ===
    # Now perform filtering (smoothing) steps if
    # the right arguments have been provided. 

    if isnothing(filt_method)
        
        # Pass, no filtering needed

    else 

        # ajr: TO DO: reimplement masking
        # # Update maskp2d to also reflect missing values 
        # maskp2d = reshape(maskp,[size(var2,1),size(var2,2)])
        # maskp2d = (maskp2d .and. var2 .ne. missing_val)

        if isnothing(filt_par)
            error("To perform filtering of filt_method="*filt_method*", filt_par must be provided.")
        end

        if filt_method == "gaussian"
            # Gaussian filter 
            sigma = filt_par[1];
            dx    = filt_par[2];
            sigma_norm = sigma / dx; 

            # Perform filtering 
            imfilter(var2, KernelFactors.gaussian((sigma_norm,sigma_norm)) );
            
        elseif filt_method == "poisson"
            # Poisson filter

            error("Poisson filter not yet implemented.")

        elseif filt_method == "none"
            # No filtering 

            # Pass, do nothing. 

        else

            error("map_scrip_field:: Error: filtering method not recognized: "*filt_method)

        end

    end

    # Finally, convert var2 type to match that of input var1 
    var2 = convert.(eltype(var1),var2);

    if verbose
        println("map_scrip_field:: mapped "*var_name)
    end

    return mask2, var2

end

function fill_weighted!(var::Matrix{<:Number};xx::Union{Nothing,Matrix{Union{Missing, Float64}}}=nothing,
    yy::Union{Nothing,Matrix{Union{Missing, Float64}}}=nothing,nmax::Integer=10,ntree::Integer=100)

    # Consistency checks
    @assert nmax > 0 
    @assert ntree >= nmax 

    # Determine which points need to be filled in
    kk = findall(isnan.(var));
    
    if length(kk) > 0
        # NaNs are present, make sure the 2D 
        # x and y locations are defined.

        if isnothing(xx) || isnothing(yy)
            # Get indices of matrix
            inds = CartesianIndices(var);

            if isnothing(xx)
                xx = Float64.(getindex.(inds,1)); 
            end
            
            if isnothing(yy)
                yy = Float64.(getindex.(inds,2));
            end
        
        end

        # Populate a matrix of x and y locations
        locs = fill(NaN,2,length(var));
        locs[1,:] = reshape(xx,length(var));
        locs[2,:] = reshape(yy,length(var));

        # Generate KD-tree of locations
        kdtree = KDTree(locs);

        while length(kk) > 0
            # Iterate until all NaNs are filled in

            # Loop over missing values and fill in with closest neighbor
            for k in kk
                xy_now = [xx[k],yy[k]];

                # Get many neighbors since some will be missing
                # e.g., ntree=100 or ntree=1000
                ii, dists = knn(kdtree, xy_now, ntree, true);

                # Determine which nearest neighbors are not missing
                kk1 = findall(.!isnan.(var[ii]));

                if length(kk1) > 0

                    # Limit length to nmax
                    n = min(length(kk1),nmax);
                    kk1 = kk1[1:n];
                    
                    if n == 1
                        # Nearest neighbor, only one value used
                        var[k] = var[ii[kk1[1]]];
                    else
                        # Weighted average of non-missing neighbors up to nmax neighbors
                        vals = var[ii[kk1[1:n]]];
                        wts  = 1.0 ./ (dists[kk1[1:n]] .+ 1e-10);

                        var[k] = vec_stat(vals;wts,method="mean")

                    end
                end

            end

            # Update NaN count 
            kk = findall(isnan.(var));
            
        end

    end

    return
end

fill_nearest!(var::Matrix{<:Number};xx::Union{Nothing,Matrix{Union{Missing, Float64}}}=nothing,
yy::Union{Nothing,Matrix{Union{Missing, Float64}}}=nothing,ntree::Integer=100) = fill_weighted!(var;xx,yy,nmax=1,ntree)

function vec_stat(var::Vector{<:Number};wts::Vector{<:Number}=repeat([1.0],length(var)),
                                                                method::String="mean")

    # Calculate the total weight associated with this point,
    # accounting for missing values in the source array.
    kk = findall(.! isnan.(var));
    wts_tot = sum(wts[kk]);

    if wts_tot > 0.0 
        # Interpolation data found, proceed to interpolate this point

        if method == "mean"
            # Calculate the area-weighted mean 

            var_out = sum((wts[kk] ./ wts_tot) .* var[kk])
        
        elseif method == "count"
            # Choose the most frequently occurring value, weighted by area

            tmp = countoccurances(var[kk];wts=wts[kk]);
            var_out = findmax(tmp)[2]; 
        
        elseif method == "stdev"
            # Calculate the weighted standard deviation 
            # using unbiased estimator correction 

            npt_now = length(kk);

            if npt_now > 2
                # Only calculate stdev for 2 or more input points

                pt_ave      = sum((wts[kk] ./ wts_tot) .* var[kk])
                var_out = (npt_now/(npt_now - 1.0)) *
                                sum((wts[kk] ./ wts_tot) .* (var[kk] .- pt_ave).^2)
                var_out = sqrt(var_out);

            else
                # Otherwise assume standard deviation is zero 
                var_out = 0.0 

            end

        else

            error("Method not recognized. method = $method")
        
        end
    
    else
        # No values available for calculation

        var_out = NaN;
    
    end

    return var_out

end